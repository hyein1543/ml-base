# -*- coding: utf-8 -*-
"""07_lr_real_estate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dzoOYVjXpfnrXP9aS5eG1hKPUTnzvpXf

# 선형회귀 - 가격 예측
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import random

SEED = 42 # 변경가능

random.seed(SEED)
np.random.seed(SEED)

np.set_printoptions(precision=4, linewidth=200) # 소수점 네번째 수 까지만 표시

"""# 데이터 준비

## 데이터 로딩
"""

# !unzip /content/real+estate+valuation+data+set.zip

# 엑셀용 라이브러리 설치
# !pip install openpyxl

df = pd.read_excel('/content/Real estate valuation data set.xlsx')
df.shape

df.head()

df.info()

df.columns # 이건 객체형태

org_columns_names = df.columns.to_list() # 리스트형태로 바꿔주기

new_columns = ["No", "X1","X2", "X3", "X4", "X5", "X6", "y"]
df.columns = new_columns
df.head()

org_columns_names

"""## EDA"""

df.info()

df.describe().T

df.isna().sum()

"""# 데이터 분리"""

from sklearn.model_selection import train_test_split

train, test = train_test_split(df, test_size=0.2, shuffle=True, random_state=SEED)

train.shape, test.shape

X_train = train.drop(columns=["X1", "y"], axis=1)
X_train.head()

y_train = train["y"]
y_train.head()

"""# 데이터 전처리
- 스케일링만

## 스케일링
"""

from sklearn.preprocessing import StandardScaler

xss = StandardScaler()

X_train_s = xss.fit_transform(X_train) # 스케일러 함수 쓰면 데이터 타입이 numpy로 바뀜
X_train_s[:10]

yss = StandardScaler()
y_train_s = yss.fit_transform(y_train.to_numpy().reshape(-1,1)) # 함수에서 2차원 이상만 처리할 수 있도록 함. np로 2차원으로 바꿔주기
y_train_s = y_train_s.reshape(-1)
y_train_s[:10]

"""## 최종 학습 데이터"""

type(X_train_s), type(y_train_s), X_train_s.shape, y_train_s.shape

"""# 모델 (베이스라인)
- 학습
"""

from sklearn.linear_model import LinearRegression

model = LinearRegression()
model.fit(X_train_s, y_train_s)

model.coef_, model.intercept_ # 절편

"""# 테스트

- X, y 분리
- 스케일링
"""

test.head()

X_test = test.drop(["X1","y"], axis=1) # 쓸모없는 컬럼과 타겟컬럼 빼기
y_test = test["y"]

X_test.shape, y_test.shape

# 결측치
X_test.isna().sum()

"""## 스케일링"""

X_test_s = xss.transform(X_test) # fit_transform 사용X-> 그럼 테스트 데이터에서 다시 mean, std 계산

y_test_s = yss.transform(y_test.to_numpy().reshape(-1,1)).reshape(-1)
y_test_s[:10]

"""## 최종 테스트 데이터"""

type(X_test_s), type(y_test_s), X_test_s.shape, y_test_s.shape

y_pred_s = model.predict(X_test_s)
y_pred_s[:10]

y_test_s[:10]

# 스케일링한거 원본으로 돌리기
y_pred = yss.inverse_transform(y_pred_s.reshape(-1,1)).reshape(-1)
y_pred[:10]

y_test.to_numpy()[:10]

"""# 평가"""

from sklearn.metrics import mean_squared_error, r2_score

def print_metrics(y_true, y_pred):
  mse = mean_squared_error(y_true, y_pred)
  r2  = r2_score(y_true, y_pred)
  print(f"MSE : {mse}, R2 : {r2}")

print_metrics(y_test, y_pred)

"""# Ridge"""

from sklearn.linear_model import Ridge

ridge = Ridge()
ridge.fit(X_train_s, y_train_s)

y_pred_ridge_s = ridge.predict(X_test_s)
y_pred_ridge = yss.inverse_transform(y_pred_ridge_s.reshape(-1,1)).reshape(-1)

print_metrics(y_test, y_pred_ridge)

"""# Lasso"""

from sklearn.linear_model import Lasso

lasso = Lasso()
lasso.fit(X_train_s, y_train_s)

y_pred_lasso_s = lasso.predict(X_test_s)
y_pred_lasso = yss.inverse_transform(y_pred_lasso_s.reshape(-1,1)).reshape(-1)

print_metrics(y_test, y_pred_lasso)

print("LR")
print_metrics(y_test, y_pred)
print("Ridge")
print_metrics(y_test, y_pred_ridge)
print("Lasso")
print_metrics(y_test, y_pred_lasso)

df.head(15)

